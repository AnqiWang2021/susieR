% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/susie_rss.R
\name{susie_rss}
\alias{susie_rss}
\title{Sum of Single Effects (SuSiE) Regression using summary statistics}
\usage{
susie_rss(
  z,
  R,
  maf = NULL,
  maf_thresh = 0,
  z_ld_weight = 0,
  L = 10,
  prior_variance = 50,
  prior_weights = NULL,
  null_weight = NULL,
  estimate_prior_variance = TRUE,
  estimate_prior_method = c("optim", "EM", "simple"),
  check_null_threshold = 0,
  prior_tol = 1e-09,
  max_iter = 100,
  s_init = NULL,
  coverage = 0.95,
  min_abs_corr = 0.5,
  tol = 0.001,
  verbose = FALSE,
  track_fit = FALSE,
  check_R = FALSE,
  r_tol = 1e-08,
  refine = FALSE
)
}
\arguments{
\item{z}{A p-vector of z scores.}

\item{R}{A p by p symmetric, positive semidefinite correlation
matrix.}

\item{maf}{Minor allele frequency; to be used along with
\code{maf_thresh} to filter input summary statistics.}

\item{maf_thresh}{Variants having a minor allele frequency smaller
than this threshold are not used.}

\item{z_ld_weight}{(This parameter is included for backwards compatibility
with previous versions of the function, but it is no longer recommended to use a non-zero value).
If \code{z_ld_weight >
  0}, the matrix R used in the model is adjusted to be \code{cov2cor((1-w)*R +
  w*tcrossprod(z))}, where \code{w = z_ld_weight}.}

\item{L}{Maximum number of components (nonzero coefficients) in the susie
regression model. If L is larger than the number of covariates, p,
L is set to p.}

\item{prior_variance}{The prior variance(s) for the non-zero element of \eqn{b_l}. It is either a scalar or
a vector of length L.}

\item{prior_weights}{A vector of length p, in which each entry
gives the prior probability that SNP j has non-zero effect.}

\item{null_weight}{Prior probability of no effect (a number between
0 and 1, and cannot be exactly 1).}

\item{estimate_prior_variance}{If \code{estimate_prior_variance =
TRUE}, the prior variance is estimated (this is a separate
parameter for each of the L effects). If provided,
\code{prior_variance} is then used as an initial value for
the optimization. When \code{estimate_prior_variance = FALSE}, the
prior variance for each of the L effects is determined by the
value supplied to \code{prior_variance}.}

\item{estimate_prior_method}{The method used for estimating prior
variance. When \code{estimate_prior_method = "simple"} is used, the
likelihood at the specified prior variance is compared to the
likelihood at a variance of zero, and the setting with the larger
likelihood is retained.}

\item{check_null_threshold}{When the prior variance is estimated,
compare the estimate with the null, and set the prior variance to
zero unless the log-likelihood using the estimate is larger by this
threshold amount. For example, if you set
\code{check_null_threshold = 0.1}, this will "nudge" the estimate
towards zero when the difference in log-likelihoods is small. A
note of caution that setting this to a value greater than zero may
lead the IBSS fitting procedure to occasionally decrease the ELBO.}

\item{prior_tol}{When the prior variance is estimated, compare the
estimated value to \code{prior_tol} at the end of the computation,
and exclude a single effect from PIP computation if the estimated
prior variance is smaller than this tolerance value.}

\item{max_iter}{Maximum number of IBSS iterations to perform.}

\item{s_init}{A previous susie fit with which to initialize.}

\item{coverage}{A number between 0 and 1 specifying the
\dQuote{coverage} of the estimated confidence sets.}

\item{min_abs_corr}{Minimum absolute correlation allowed in a
credible set. The default, 0.5, corresponds to a squared
correlation of 0.25, which is a commonly used threshold for
genotype data in genetic studies.}

\item{tol}{A small, non-negative number specifying the convergence
tolerance for the IBSS fitting procedure. The fitting procedure
will halt when the difference in the variational lower bound, or
\dQuote{ELBO} (the objective function to be maximized), is
less than \code{tol}.}

\item{verbose}{If \code{verbose = TRUE}, the algorithm's progress,
and a summary of the optimization settings, are printed to the
console.}

\item{track_fit}{If \code{track_fit = TRUE}, \code{trace}
is also returned containing detailed information about the
estimates at each iteration of the IBSS fitting procedure.}

\item{check_R}{If \code{check_R = TRUE}, check that \code{R} is
positive semidefinite.}

\item{r_tol}{Tolerance level for eigenvalue check of positive
semidefinite matrix of R.}

\item{refine}{If \code{refine = TRUE}, then an additional
iterative refinement procedure is used, after the IBSS algorithm,
to check and escape from local optima (see \code{\link{susie}} details).}
}
\value{
A \code{"susie"} object with the following
  elements:

\item{alpha}{An L by p matrix of posterior inclusion probabilites.}

\item{mu}{An L by p matrix of posterior means, conditional on
  inclusion.}

\item{mu2}{An L by p matrix of posterior second moments,
  conditional on inclusion.}

\item{lbf}{log-Bayes Factor for each single effect.}

\item{lbf_variable}{log-Bayes Factor for each variable and single effect.}

\item{V}{Prior variance of the non-zero elements of b.}

\item{elbo}{The value of the variational lower bound, or
  \dQuote{ELBO} (objective function to be maximized), achieved at
  each iteration of the IBSS fitting procedure.}

\item{Rr}{A vector of length p, equal to \code{R \%*\% colSums(alpha*mu)}.}

\item{sets}{Credible sets estimated from model fit; see
  \code{\link{susie_get_cs}} for details.}

\item{pip}{A vector of length p giving the (marginal) posterior
  inclusion probabilities for all p covariates.}

\item{niter}{Number of IBSS iterations that were performed.}

\item{converged}{\code{TRUE} or \code{FALSE} indicating whether
  the IBSS converged to a solution within the chosen tolerance
  level.}
}
\description{
\code{susie_rss}
performs variable selection under a sparse Bayesian multiple linear regression
of \eqn{Y} on \eqn{X} using only the \eqn{z} scores from standard univariate regression of
 \eqn{Y} on each column of \eqn{X}, and an estimate \eqn{R} of the correlation matrix
 between columns of \eqn{X}.  It does this by combining the "RSS likelihood" from Zhu and Stephens (2017) with the
  Sum of Single Effects" model from Wang et al (2020).
}
\details{
In some applications, particularly genetic applications,
it is desired to fit a regression model (\eqn{Y = X\tilde{b} +E} say,
which we refer to as "the original regression model" or ORM) without access
to the actual values of \eqn{Y} and \eqn{X}, but given only some summary statistics.
\code{susie_rss} assumes the availability of \eqn{z} scores from standard univariate regression of
 \eqn{Y} on each column of \eqn{X}, and an estimate \eqn{R} of the correlation matrix
 between columns of \eqn{X} (\eqn{R} is sometimes called the LD matrix in genetic applications).
 See Zhu and Stephens (2017), and references therein, for further background.

 The \code{susie_rss} function is based on the model (2.10) from Zhu and Stephens,  \eqn{z | R, b ~ N(Rb,R)}
where \eqn{b} is a vector of length p representing the effects to be estimated. The effect
\eqn{b_j} is simply a multiple of the coefficient \eqn{\tilde{b}_j} in the ORM,
and so \eqn{b_j} is non-zero if and only if \eqn{\tilde{b}_j} is non-zero. In this
sense the variable selection problem in this model is the same as the variable selection
problem in the ORM, and so the credible sets and PIPs computed by \code{susie_rss}
can be interpreted as credible sets and PIPs for the ORM. However, converting posterior estimates of \eqn{b_j} to estimates
of \eqn{\tilde{b}_j} would require computation of the scaling factor (not done here).

More precisely
\code{susie_rss} assumes the
log-likelihood for \eqn{b} is \eqn{l(b; z,R) = 0.5 b'Rb - z'b},
which is equivalent to model (2.10) from Zhu and Stephens if \eqn{R} is invertible,
but does not require \eqn{R} to be invertible.
It combines this likelihood with the \dQuote{susie prior} which assumes that \eqn{b = \sum_{l=1}^L b_l} where each
  \eqn{b_l} is a vector of length p with exactly one non-zero element; see
  \code{\link{susie}} and Wang et al (2020) for details. In practice
  this is accomplished by calling \code{susie_suff_stat} with \code{XtX = R}
  and \code{Xty = z}, and fixing \code{residual_variance=1}.
}
\examples{
set.seed(1)
n = 1000
p = 1000
beta = rep(0,p)
beta[1:4] = 1
X = matrix(rnorm(n*p),nrow = n,ncol = p)
X = scale(X,center = TRUE,scale = TRUE)
y = drop(X \%*\% beta + rnorm(n))

input_ss <- compute_suff_stat(X,y,standardize = TRUE)
ss   <- univariate_regression(X,y)
R    <- with(input_ss,cov2cor(XtX))
zhat <- with(ss,betahat/sebetahat)
res  <- susie_rss(zhat,R,L = 10)

}
\references{
G. Wang, A. Sarkar, P. Carbonetto and M. Stephens (2020). A simple
  new approach to variable selection in regression, with application
  to genetic fine-mapping. \emph{Journal of the Royal Statistical
  Society, Series B} \url{https://doi.org/10.1101/501114}.

X. Zhu and M. Stephens (2017). Bayesian large-scale multiple regression
with summary statistics from genome-wide association studies.
\emph{Annals of Applied Statistics} 11(3): 1561-1592.
}
