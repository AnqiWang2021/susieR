---
title: "sparse multiplication eval"
author: "Kaiqian Zhang"
date: "9/10/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
devtools::install_local("~/Desktop/M/M-github-repos/susieR-sparse-v3")
library(Matrix)
library(ggplot2)
library(microbenchmark)
library(susieR)
```

## Goal
In this vignette, we will evaluate three methods of matrix multiplication and determine which one should be applied to the revised version of SuSiE. 

## Data
```{r}
create_sparsity_mat = function(sparsity, n, p){
  nonzero = round(n*p*(1-sparsity))
  nonzero.idx = sample(n*p, nonzero)
  mat = numeric(n*p)
  mat[nonzero.idx] = 1
  mat = matrix(mat, nrow=n, ncol=p)
  return(mat)     
}
```

```{r}
set.seed(1)
n = 1000
p = 10000
beta = rep(0,p)
beta[1]    = 10 
beta[300]  = 10
beta[400]  = 10
beta[1000] = 10

X.unscaled.dense = create_sparsity_mat(0.99,n,p)
X.unscaled.sparse = as(X.unscaled.dense,'dgCMatrix')
X.unscaled.dense = susieR:::safe_colScale(X.unscaled.dense)
X.unscaled.sparse = susieR:::safe_colScale(X.unscaled.sparse)
X.scaled.dense = attr(X.unscaled.dense, 'scaled.X')
```

## Methods

### Direct dense matrix multiplication

* apply %*% directly to a dense and scaled X;

* apply crossprod directly to a dense and scaled X;

### 'Transformed' matrix multiplication

* apply %*% to an unscaled X (no matter dense or sparse) and then subtract the centering and standardization part.

## Multiplications

There are two types of matrix multiplications occurred in the SuSiE.

(1) compute_Xy: an n by p matrix `X` multiplied by a p vector `y`;

(2) compute_Xty: an n by p matrix `X` transformed first, then multiplied by an n vector `y`. 

## compute_Xy
Given a dense matrix `X`, the benchmark shows that we should use direct mutiplication `%*%` in the `compute_Xy`. 

```{r}
compute_Xy_direct_mul = function(X,y){
  return(X%*%y)
}
```

```{r}
compute_Xy_direct_cros = function(X,y){
  return(tcrossprod(X,t(y)))
}
```

```{r}
compute_Xy_transform = function(X,y){
  cm = attr(X, 'scaled:center')
  csd = attr(X, 'scaled:scale')
  #scale Xy
  scaled.X  <- t(t(X)/csd)
  scaled.Xy <- tcrossprod(scaled.X,t(y))
  #center Xy
  Xy <- scaled.Xy - sum(cm*y/csd) 
  return(as.numeric(Xy))
}
```

```{r}
y = rnorm(p)
```

```{r}
benchmark_compute_Xy_dense = microbenchmark(
  direct_mul = compute_Xy_direct_mul(X.scaled.dense, y),
  direct_cros = compute_Xy_direct_cros(X.scaled.dense, y),
  transform = compute_Xy_transform(X.unscaled.dense, y),
  times = 10
)
```

```{r}
autoplot(benchmark_compute_Xy_dense)
```

Given a sparse matrix `X`, it is also better to use direct multiplication `%*%` in the `compute_Xy`.
```{r}
benchmark_compute_Xy_sparse = microbenchmark(
  direct_mul = compute_Xy_direct_mul(X.scaled.dense, y),
  direct_cros = compute_Xy_direct_cros(X.scaled.dense, y),
  transform = compute_Xy_transform(X.unscaled.sparse, y),
  times = 10
)
```

```{r}
autoplot(benchmark_compute_Xy_sparse)
```

## compute_Xty
Given a dense matrix `X`, we should use direct crossprod in the `compute_Xty`.

```{r}
compute_Xty_direct_mul = function(X,y){
  return(t(X)%*%y)
}
```

```{r}
compute_Xty_direct_cros = function(X,y){
  return(crossprod(X,y))
}
```

```{r}
compute_Xty_transform = function(X,y){
  cm = attr(X, 'scaled:center')
  csd = attr(X, 'scaled:scale')
  Xty        <- crossprod(X, y)
  scaled.Xty <- t(t(Xty)/csd)
  centered.scaled.Xty <- scaled.Xty - cm/csd * sum(y)     
  return(as.numeric(centered.scaled.Xty))
}
```

```{r}
y = rnorm(n)
```

```{r}
benchmark_compute_Xty_dense = microbenchmark(
  direct_mul = compute_Xty_direct_mul(X.scaled.dense, y),
  direct_cros = compute_Xty_direct_cros(X.scaled.dense, y),
  transform = compute_Xty_transform(X.unscaled.dense, y),
  times = 10
)
```

```{r}
autoplot(benchmark_compute_Xty_dense)
```

Given a sparse matrix `X`, using transform method has a great advantage. 

```{r}
benchmark_compute_Xty_sparse = microbenchmark(
  direct_mul = compute_Xty_direct_mul(X.scaled.dense, y),
  direct_cros = compute_Xty_direct_cros(X.scaled.dense, y),
  transform = compute_Xty_transform(X.unscaled.sparse, y),
  times = 10
)
```

```{r}
autoplot(benchmark_compute_Xty_sparse)
```


